
package com.eggman.tokens.compiler

import com.eggman.tokens.compiler.TokenSerialization.constructor
import com.eggman.tokens.model.token.ButtonJsonToken
import com.eggman.tokens.model.Color
import com.eggman.tokens.model.ThemeColors
import com.eggman.tokens.model.ThemeComponents
import com.eggman.tokens.model.token.DesignTokens
import com.eggman.tokens.model.token.GenerateTokens
import com.eggman.tokens.model.MortarTheme
import com.eggman.tokens.model.json.Parsers
import com.eggman.tokens.model.Typography
import com.eggman.tokens.model.ThemeTypography
import com.eggman.tokens.model.component.Button
import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.json.decodeFromStream
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.Processor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedAnnotationTypes
import javax.annotation.processing.SupportedOptions
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.TypeElement

/**
 * [TokensCompiler] is a annotation processor that takes a Mortar design data file in a json format
 * and creates theme for the json file.
 */
//note: in a new project, would probably use ksp...
@AutoService(Processor::class)
@SupportedSourceVersion(SourceVersion.RELEASE_17)
@SupportedOptions("kapt.kotlin.generated", "org.gradle.annotation.processing.incremental")
@SupportedAnnotationTypes("com.eggman.tokens.model.token.GenerateTokens")
@Suppress("unused")
class TokensCompiler : AbstractProcessor() {

    @OptIn(ExperimentalSerializationApi::class)
    override fun process(types: MutableSet<out TypeElement>?, env: RoundEnvironment): Boolean {
        env.getElementsAnnotatedWith(GenerateTokens::class.java).forEach { element ->
            val annotation = element.getAnnotation(GenerateTokens::class.java)
            javaClass.classLoader.getResourceAsStream(annotation.jsonFile)?.let {
                val designTokens = Parsers.json().decodeFromStream<DesignTokens>(it)
                buildTokensSource(annotation, designTokens)
            } ?: throw IllegalArgumentException("${annotation.jsonFile} not found! Did you include?")
        }
        return true
    }

    private fun buildTokensSource(annotation: GenerateTokens, tokens: DesignTokens) {
        val themeClass = "${annotation.themePrefix}Mortar"
        val file = FileSpec.builder(annotation.packageName, themeClass)
            .addFileComment("This file is generated by Mortar Android. Do not edit!")
        val tokenClassType = TypeSpec.objectBuilder(themeClass)

        listOf(
            stringTokenProp("Colors", tokens.primitive.colors),
            stringTokenProp("FontFamily", tokens.primitive.fontNames),
            tokenProperty("Elevation", tokens.primitive.elevation),
            tokenProperty("Motion", tokens.primitive.motion),
            tokenProperty("Radius", tokens.primitive.radius),
            tokenProperty("FontSize", tokens.primitive.fontSizes),
            tokenProperty("FontWeight", tokens.primitive.fontWeights),
        ).forEach { tokenClassType.addType(it) }

        val themeColorKey = "${annotation.themePrefix}ThemeColors"
        val themeTypoKey = "${annotation.themePrefix}ThemeTypography"
        val themeComponentsKey = "${annotation.themePrefix}ThemeComponents"

        // note: we use a lot of Object types for the generated code, a production solution would consider other design....
        // todo: can make this just a prop
        val colorScheme = TypeSpec.objectBuilder(themeColorKey).addSuperinterface(ThemeColors::class)
        tokens.semantic.colors.forEach { (key, colorTokenReference) ->
            val colorProp = PropertySpec.builder(key, Color::class)
                .addModifiers(KModifier.OVERRIDE)
                .initializer(colorTokenReference.constructor())
                .build()
            colorScheme.addProperty(colorProp)
        }
        tokenClassType.addType(colorScheme.build())

        val typographyScheme = TypeSpec.objectBuilder(themeTypoKey).addSuperinterface(ThemeTypography::class)
        tokens.semantic.typography.forEach { (key, typography) ->
            val typographyProp = PropertySpec.builder(key, Typography::class)
                .addModifiers(KModifier.OVERRIDE)
                .initializer(typography.constructor(themeColorKey))
                .build()
            typographyScheme.addProperty(typographyProp)
        }
        tokenClassType.addType(typographyScheme.build())

        val themeComponents = TypeSpec.objectBuilder(themeComponentsKey).addSuperinterface(ThemeComponents::class)
        tokens.component.forEach { (componentName, componentToken) ->
            if (componentToken is ButtonJsonToken) {
                val componentProp = PropertySpec.builder(componentName, Button::class)
                    .addModifiers(KModifier.OVERRIDE)
                    .initializer(componentToken.constructor(themeColorKey, themeTypoKey))
                    .build()
                themeComponents.addProperty(componentProp)
            }
        }
        tokenClassType.addType(themeComponents.build())

        // this would not need to be hardcoded in prod. just saving time, this is just to showcase idea around codegen of theme
        val themeColors = PropertySpec.builder("theme", MortarTheme::class)
            .initializer(
                "MortarTheme($themeColorKey, $themeTypoKey, $themeComponentsKey)"
            )
        tokenClassType.addProperty(themeColors.build())

        file.addType(tokenClassType.build())

        val generatedFile = file.build()
        generatedFile.toJavaFileObject().delete()
        generatedFile.writeTo(processingEnv.filer)
    }

    private inline fun<reified T: Number> tokenProperty(propertyName: String, tokens: Map<String, T>):TypeSpec {
        val numberProperty = TypeSpec.objectBuilder(propertyName)
        tokens.forEach {
            val numberProp = PropertySpec.builder(it.key, T::class)
                .initializer("${it.value}")
                .build()
            numberProperty.addProperty(numberProp)
        }
        return numberProperty.build()
    }

    private fun stringTokenProp(propertyName: String, tokens: Map<String, String>):TypeSpec {
        val numberProperty = TypeSpec.objectBuilder(propertyName)
        tokens.forEach {
            val numberProp = PropertySpec.builder(it.key, String::class)
                .initializer("\"${it.value}\"")
                .build()
            numberProperty.addProperty(numberProp)
        }
        return numberProperty.build()
    }
}