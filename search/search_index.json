{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Mortar Android Mortar is application design system, meant to make building UI consistent, flexible and most importantly fast. The goal of Mortar is to allow developers to focus on building new features - and less on implementation details of common ui elements. This project is the Android implementation of Mortar for Jetpack Compose. The implementation of Mortar will lean heavily on Android platform standards, and will use material 3 (m3) components where possible. The structure of this design system is based on Atomic Design Architecture The Mortar design system architecture is based on having a single source of truth. That single source of truth is the mortar design data JSON files. These JSON files are used to code-generate themes per product/brand. The JSON data would be a cross-platform owned definition of product theme implementations of MDS. Single Source of Truth The design data JSON files define the themes and their properties. These files include definitions for colors, typography, and component styles, which are used across different parts of the application to ensure consistency and flexibility. Code Generation Process The code generation process takes the JSON files and generates platform-agnostic theme implementations. This is handled by the token-compiler module, which is a Kotlin annotation processor. It reads the JSON definitions and generates Kotlin code representing the theme components. The generated files are placed in the themes module. Mortar Theme Implementation The MortarTheme class serves as a container for the generated theme values. It includes the following components: ThemeColors: Defines the color scheme for the theme. ThemeTypography: Defines the typography styles for the theme. ThemeComponents: Defines the styles for various UI components. These components are platform-agnostic and can be used in different environments, such as Kotlin Multiplatform (KMP). Compose Mapper The ComposeMapper object contains functions to convert the platform-agnostic theme values to Compose-specific values. These functions map the raw theme values (e.g., colors, typography) to their Compose counterparts (e.g., Color, TextStyle). Compose Mortar Theme The MortarComposeTheme class is the Compose-specific representation of the theme. It uses the values provided by the ComposeMapper to define the theme and its components in a format compatible with Jetpack Compose. Component API philosophy For this project, the design of our components API is more restrictive than common APIs for a compose component. We could have a \"slot\" api similar to material components, but that opens the components up to being misused and inconsistent. The decision to allow flexibility is ultimately a cross platform decision on the philosophy of customizability. Flexible components might get misused, but restrictive apis might never be used (if consuming developers find them too restrictive). Also worth noting that even though there are two custom component definitions, the less custom components we have, the better. Driving default component (ex. button) styles from semantic tokens will be easier to maintain long term compared to having a component token for every single component MDS supports. Project caveats This project serves as a demonstration of a potential architecture for the Mortar design system. Here are some important considerations: Simplified Token Coverage : In a full-scale implementation, the generated themes would include all design tokens, such as radius, elevation, and more. This demo focuses on a subset to quickly illustrate the concept. Additionally token name and structure would probably be different, as this was mainly modeled after material for simplicity. Manual Mapping : Currently, the adaptation from Mortar themes to Compose themes involves manual boilerplate code. In a real-world solution, this would likely be automated through code generation to reduce manual effort and potential errors. Consumers of the library would use a compose version of a generated theme (ex. HebMortar would have a HebMortarCompose generated theme...). Material 3 Wrapping : The decision to wrap the Material 3 theme is intentional for this demo. It was used to showcase a potential approach to still take advantage of existing M3 components with custom styling. In a complete design system, the schema and approach would be collaboratively developed by the design and engineering teams. Versioning : versioning the design data schema would need to be worked out cross platform, to ensure changes to the schema don't break any of the automation or theme implementation. Breaking changes would need to be versioned appropriately. Project Modules docs : location of the documentation you are currently reading. compose-components : a list of standard components that are very commonly used in most apps. Common examples are headers, buttons, text fields, etc... compose-core : base component code and logic that is common to all compose implementation. demo-mortar : a demo application that can be used to show mortar components in action. themes : a set of generated product specific themes. token-compiler : Kotlin annotation processor that generates the kotlin code for product specific themes. The themes are generated from Mortar design system json files. token-model : a set of generated token definitions. Versioning Mortar follows semantic versioning . All artifacts are versioned on changes to any modules. See more info at the dev guide","title":"Overview"},{"location":"#welcome-to-mortar-android","text":"Mortar is application design system, meant to make building UI consistent, flexible and most importantly fast. The goal of Mortar is to allow developers to focus on building new features - and less on implementation details of common ui elements. This project is the Android implementation of Mortar for Jetpack Compose. The implementation of Mortar will lean heavily on Android platform standards, and will use material 3 (m3) components where possible. The structure of this design system is based on Atomic Design","title":"Welcome to Mortar Android"},{"location":"#architecture","text":"The Mortar design system architecture is based on having a single source of truth. That single source of truth is the mortar design data JSON files. These JSON files are used to code-generate themes per product/brand. The JSON data would be a cross-platform owned definition of product theme implementations of MDS.","title":"Architecture"},{"location":"#single-source-of-truth","text":"The design data JSON files define the themes and their properties. These files include definitions for colors, typography, and component styles, which are used across different parts of the application to ensure consistency and flexibility.","title":"Single Source of Truth"},{"location":"#code-generation-process","text":"The code generation process takes the JSON files and generates platform-agnostic theme implementations. This is handled by the token-compiler module, which is a Kotlin annotation processor. It reads the JSON definitions and generates Kotlin code representing the theme components. The generated files are placed in the themes module.","title":"Code Generation Process"},{"location":"#mortar-theme-implementation","text":"The MortarTheme class serves as a container for the generated theme values. It includes the following components: ThemeColors: Defines the color scheme for the theme. ThemeTypography: Defines the typography styles for the theme. ThemeComponents: Defines the styles for various UI components. These components are platform-agnostic and can be used in different environments, such as Kotlin Multiplatform (KMP).","title":"Mortar Theme Implementation"},{"location":"#compose-mapper","text":"The ComposeMapper object contains functions to convert the platform-agnostic theme values to Compose-specific values. These functions map the raw theme values (e.g., colors, typography) to their Compose counterparts (e.g., Color, TextStyle).","title":"Compose Mapper"},{"location":"#compose-mortar-theme","text":"The MortarComposeTheme class is the Compose-specific representation of the theme. It uses the values provided by the ComposeMapper to define the theme and its components in a format compatible with Jetpack Compose.","title":"Compose Mortar Theme"},{"location":"#component-api-philosophy","text":"For this project, the design of our components API is more restrictive than common APIs for a compose component. We could have a \"slot\" api similar to material components, but that opens the components up to being misused and inconsistent. The decision to allow flexibility is ultimately a cross platform decision on the philosophy of customizability. Flexible components might get misused, but restrictive apis might never be used (if consuming developers find them too restrictive). Also worth noting that even though there are two custom component definitions, the less custom components we have, the better. Driving default component (ex. button) styles from semantic tokens will be easier to maintain long term compared to having a component token for every single component MDS supports.","title":"Component API philosophy"},{"location":"#project-caveats","text":"This project serves as a demonstration of a potential architecture for the Mortar design system. Here are some important considerations: Simplified Token Coverage : In a full-scale implementation, the generated themes would include all design tokens, such as radius, elevation, and more. This demo focuses on a subset to quickly illustrate the concept. Additionally token name and structure would probably be different, as this was mainly modeled after material for simplicity. Manual Mapping : Currently, the adaptation from Mortar themes to Compose themes involves manual boilerplate code. In a real-world solution, this would likely be automated through code generation to reduce manual effort and potential errors. Consumers of the library would use a compose version of a generated theme (ex. HebMortar would have a HebMortarCompose generated theme...). Material 3 Wrapping : The decision to wrap the Material 3 theme is intentional for this demo. It was used to showcase a potential approach to still take advantage of existing M3 components with custom styling. In a complete design system, the schema and approach would be collaboratively developed by the design and engineering teams. Versioning : versioning the design data schema would need to be worked out cross platform, to ensure changes to the schema don't break any of the automation or theme implementation. Breaking changes would need to be versioned appropriately.","title":"Project caveats"},{"location":"#project-modules","text":"docs : location of the documentation you are currently reading. compose-components : a list of standard components that are very commonly used in most apps. Common examples are headers, buttons, text fields, etc... compose-core : base component code and logic that is common to all compose implementation. demo-mortar : a demo application that can be used to show mortar components in action. themes : a set of generated product specific themes. token-compiler : Kotlin annotation processor that generates the kotlin code for product specific themes. The themes are generated from Mortar design system json files. token-model : a set of generated token definitions.","title":"Project Modules"},{"location":"#versioning","text":"Mortar follows semantic versioning . All artifacts are versioned on changes to any modules. See more info at the dev guide","title":"Versioning"},{"location":"dev_guide/","text":"Developer guide The Mortar design system currently supports jetpack compose. Getting started First, bring in the required dependencies from artifactory: dependencies { implementation(\"com.eggman.mortar:compose-components:0.0.1\") implementation(\"com.eggman.mortar:themes:0.0.1\") } The themes project will bring in all product themes from MDS, but don't worry - R8 will get rid of unused classes when compiling a release build. Next, to use Mortar you can wrap all of your composable code with MaterialMortarTheme . Mortar currently uses material 3 components internally. MaterialMortarTheme( theme = HebMortar.theme, isInDarkTheme = isSystemInDarkTheme(), ) { //your compose code goes here.... } Current themes available: HebMortar.theme // heb CmMortar.theme // central market Using theme properties It is recommended that you use components if they already exist, but you still might sometimes need to drive some of your UI with theme values. To do this, access colors/typography/components from any composable code that is within a MaterialMortarTheme : LocalMortarTypography.current // access to theme typography LocalMortarColorScheme.current // access to theme colors LocalMortarComponents.current // access to theme component properties. Adding/Updating themes To update a existing theme to the latest values, simply get the design data json from the design data repository, and drop it into token-compiler/resources , overwrite existing. To add a new theme, drop the new theme design data json file in token-compiler/resources . Then you need to create a new definition in the themes module, specifically inside of DesignTokens.kt . For example, if we were going to add a new theme for a product called \"string cheese\", it would look like this: @GenerateTokens( themePrefix = \"Sc\", jsonFile = \"sc_tokens.json\", ) internal object StringCheeseTokenSchema drop json file called sc_tokens.json into token-compiler/resources . Breaking Changes To support semantic versioning, this project uses the binary-compatibility-validator plugin. Run the following command to dump the current api as the baseline version to compare against: ./gradlew apiDump After running this command, you will see .api files located in each module that is public facing. These files should be committed into source control. Everytime a new version is released, the api baseline should be updated accordingly. When making changes, you can verify if you have binary incompatible changes by running: ./gradlew apiCheck Publishing To publish all modules (which is desirable), simply run from terminal: ./gradlew publish This will build and publish aars/jars of modules locally for now. You can see these generated artifacts in build/repos/com/eggman/mortar . Each publication will include sources and docs jar so that developers consuming these components can debug in the library and see all code documentation. In a production environment, these would hopefully be managed via a mature maven repository system like Artifactory.","title":"Dev Guide"},{"location":"dev_guide/#developer-guide","text":"The Mortar design system currently supports jetpack compose.","title":"Developer guide"},{"location":"dev_guide/#getting-started","text":"First, bring in the required dependencies from artifactory: dependencies { implementation(\"com.eggman.mortar:compose-components:0.0.1\") implementation(\"com.eggman.mortar:themes:0.0.1\") } The themes project will bring in all product themes from MDS, but don't worry - R8 will get rid of unused classes when compiling a release build. Next, to use Mortar you can wrap all of your composable code with MaterialMortarTheme . Mortar currently uses material 3 components internally. MaterialMortarTheme( theme = HebMortar.theme, isInDarkTheme = isSystemInDarkTheme(), ) { //your compose code goes here.... } Current themes available: HebMortar.theme // heb CmMortar.theme // central market","title":"Getting started"},{"location":"dev_guide/#using-theme-properties","text":"It is recommended that you use components if they already exist, but you still might sometimes need to drive some of your UI with theme values. To do this, access colors/typography/components from any composable code that is within a MaterialMortarTheme : LocalMortarTypography.current // access to theme typography LocalMortarColorScheme.current // access to theme colors LocalMortarComponents.current // access to theme component properties.","title":"Using theme properties"},{"location":"dev_guide/#addingupdating-themes","text":"To update a existing theme to the latest values, simply get the design data json from the design data repository, and drop it into token-compiler/resources , overwrite existing. To add a new theme, drop the new theme design data json file in token-compiler/resources . Then you need to create a new definition in the themes module, specifically inside of DesignTokens.kt . For example, if we were going to add a new theme for a product called \"string cheese\", it would look like this: @GenerateTokens( themePrefix = \"Sc\", jsonFile = \"sc_tokens.json\", ) internal object StringCheeseTokenSchema drop json file called sc_tokens.json into token-compiler/resources .","title":"Adding/Updating themes"},{"location":"dev_guide/#breaking-changes","text":"To support semantic versioning, this project uses the binary-compatibility-validator plugin. Run the following command to dump the current api as the baseline version to compare against: ./gradlew apiDump After running this command, you will see .api files located in each module that is public facing. These files should be committed into source control. Everytime a new version is released, the api baseline should be updated accordingly. When making changes, you can verify if you have binary incompatible changes by running: ./gradlew apiCheck","title":"Breaking Changes"},{"location":"dev_guide/#publishing","text":"To publish all modules (which is desirable), simply run from terminal: ./gradlew publish This will build and publish aars/jars of modules locally for now. You can see these generated artifacts in build/repos/com/eggman/mortar . Each publication will include sources and docs jar so that developers consuming these components can debug in the library and see all code documentation. In a production environment, these would hopefully be managed via a mature maven repository system like Artifactory.","title":"Publishing"},{"location":"testing/","text":"Testing guide The Mortar design system currently has several different types of tests you can run: Unit tests ./gradlew test This will run all jvm based unit tests, which includes junit tests and paparazzi tests. After running, you can see test reports in all modules with junit tests at: build/reports/tests/index.html Snapshot tests This project uses paparazzi for snapshot testing. Tests will run when executing ./gradlew test as these tests are jvm based. After running, you can see reports at: compose-components/build/reports/paparazzi/debug/index.html compose-components/build/reports/paparazzi/release/index.html To update paparazzi screenshots used to detect breaking changes, run: ./gradlew recordPaparazziDebug The screenshots will be located in compose-components/src/test/snapshots To verify your changes do not have breaking UI changes with paparazzi, run: ./gradlew verifyPaparazziDebug Sometimes, you might have changes that are intentional and breaking (visually ) Android instrumentation tests To run android instrumentation tests, ensure you have a device or emulator running and connected to your machine, and run: ./gradlew connectedAndroidTest View reports in android modules at: build/reports/androidTests/connected/debug/index.html","title":"Testing"},{"location":"testing/#testing-guide","text":"The Mortar design system currently has several different types of tests you can run:","title":"Testing guide"},{"location":"testing/#unit-tests","text":"./gradlew test This will run all jvm based unit tests, which includes junit tests and paparazzi tests. After running, you can see test reports in all modules with junit tests at: build/reports/tests/index.html","title":"Unit tests"},{"location":"testing/#snapshot-tests","text":"This project uses paparazzi for snapshot testing. Tests will run when executing ./gradlew test as these tests are jvm based. After running, you can see reports at: compose-components/build/reports/paparazzi/debug/index.html compose-components/build/reports/paparazzi/release/index.html To update paparazzi screenshots used to detect breaking changes, run: ./gradlew recordPaparazziDebug The screenshots will be located in compose-components/src/test/snapshots To verify your changes do not have breaking UI changes with paparazzi, run: ./gradlew verifyPaparazziDebug Sometimes, you might have changes that are intentional and breaking (visually )","title":"Snapshot tests"},{"location":"testing/#android-instrumentation-tests","text":"To run android instrumentation tests, ensure you have a device or emulator running and connected to your machine, and run: ./gradlew connectedAndroidTest View reports in android modules at: build/reports/androidTests/connected/debug/index.html","title":"Android instrumentation tests"}]}